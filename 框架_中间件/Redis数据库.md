# Redis数据库
[toc]
## 什么是Redis？
Redis(Remote Dictionary Server远程字典服务)，这是一款高性能的(key/value，键值对)**分布式内存数据库**。它基于**内存运行**并支持**持久化**的NoSQL数据库。支持丰富的数据类型并且支持事务，事务中的所有命令会被**序列化**、**按顺序运行**，在执行过程中不会被其他客户端发送过来的命令打断。

## Redis与Memcached的对比
- Memcached仅支持简单的字符串类型的数据，Redis支持更为丰富的数据类型。
- Redis的速度更快，而且还支持持久化。
- Redis支持数据的备份，即Master-Slave的数据备份。
- 底层模型的不同，它们之间的底层实现方式以及与客户端之间通信的**应用协议**不一样，Redis自己构建了VM管理机制。
- 数据大小不同，Redis最大可以达到512MB，Memcached只有1MB。

## Redis支持的数据类型及应用场景
Redis支持**五种**数据类型最为它的Value，**Key都是字符串类型的**。
- String：最常见，最大可为512MB。可以用来做一些**计数功能**的缓存。
- List：简单的字符串列表，按照插入顺序排序，底层实现是一个链表。可以实现一个简单的消息队列功能，做基于Redis的分页功能等。
- Set：字符串类型的无序集合。可以用来全局去重等。
- Sorted Set：字符串类型的有序集合，给每一个元素设置一个固定的**分数score**来保持顺序。可以用来做排行榜或者进行范围查找等。
- Hash：键值对集合，字符串类型的Key和Value的映射表。可以用来存放一些具有特定结构的信息。

## Redis是单线程的吗？为什么执行速度那么快？
是单线程，这里的单线程是指网络请求模块使用了一个线程，所以不需考虑并发安全性。但是对于需要依赖多个操作的复合操作来说，还是需要锁的，而且有可能是分布式锁。
### 为什么快？
- 基于**内存实现**，完全内存计算。
- 单线程操作，**避免了线程上下文切换操作**。
- **多路I/O复用的线程模型**，实现了一个线程监控多个I/O流，及时响应请求。
- **对外部的依赖比较少**，属于轻量级内存数据库。
### 多路I/O复用机制
目前支持I/O多路复用的系统调用有**select、pselect、poll、epoll**等函数。I/O多路复用就是通过一种机制**一个进程可以监控多个描述符**，一旦某个描述符读/写就绪，其能够通知应用程序进行相应的读写操作。该技术相比多进程和多线程来说，系统开销小，不必创建进程/线程，所以也不用维护这些进程/线程，从而大大减小了系统的开销。

## 使用Redis可能出现的问题
### 缓存雪崩
具体情况：缓存在同一时间大面积的失效，而这个时候又有一波对数据库的请求，请求过多导致数据库的连接异常。
解决方法：给缓存设置不同的失效时间，更新数据的时候使用互斥锁或者通过双缓存来避免缓存雪崩。
### 缓存穿透
具体情况：请求缓存中不存在的数据，导致请求直接去到了数据库上，导致数据库异常。
解决方法：可以使用互斥锁或者无论是否取到结果都将结果存入缓存，还可以使用有效的机制来拦截不合法的key值。
### 数据库和缓存的双写一致性问题
在高并发请求下很容易导致数据不一致的问题。在数据库中和缓存数据的删除或者写入过程中，如果有失败的情况，会导致数据的不一致。
解决方法：
- 双删延时：先删除缓存数据，然后更新数据库数据，最后再隔固定的时间再次删除缓存。
- 更新数据库产生的binlog订阅(使用canal)：将有变化的Key记录下来，并尝试不断地去删除缓存。

## Redis地持久化方式有哪些？
Redis地持久化方式有两种，即RDB和AOF地方式。
### RDB(快照，Snapshotting，全量持久化)
将当前内存地数据集快照写入磁盘，实现数据地持久化，恢复时可以将快照重新载入内存。

触发方式：
- 自动触发：在配置文件种，可以配置执行多少次save就自动触发自动持久化。
- 手动触发：通过bgsave命令，在后台异步进行生成快照地操作，同时还可以响应客户端地请求。通过Redis进程fork操作创建子进程，生成地快照由子进程负责，客户端请求只会在fork阶段被阻塞。
- 
快照恢复：
将备份文件(dump.rdb)移动到Redis安装目录并启动服务，Redis会自动加载快照文件数据到内存。但是Redis服务器在载入RDB文件期间，会一直处于阻塞状态，直到载入工作完成为止。

优缺点分析：
- RDB持久化方式存在**数据丢失**的问题，因为其没有办法实现实时持久化。因为bgsave每次运行都要执行fork操作创建子进程，属于**重量级操作**，频繁执行成本过高，会影响系统性能。自动触发也存在丢失部分数据的情况。
- 在恢复大数据集的时候，RDB方式相对于AOF要快。

### AOF(Append-Only-File，增量持久化)
在Redis配置文件的APPEND ONLY MODE中，可以设置AOF持久化。通过记录Redis服务器所执行的写命令来记录数据库状态。恢复时可以将AOF文件载入内存，并且可以通过**redis-check-aof --fix**进行AOF文件修复。

AOF日志重写：
- AOF文件会随着服务器运行时间的增加而变得越来越大，可以通过AOF重写来控制AOF文件的大小。
- AOF重写会先读取数据库中现有的键值对状态，然后根据类型使用一条命令来替代前面对键值对操作的多条命令。
- 使用命令bgrewriteaof来实现AOF重写。

AOF重写缓存区：
Redis时单线程工作的，当AOF文件较大时重写时间会比较长，在重写AOF期间，Redis将长时间无法处理客户端请求。为了解决这个问题，可以将AOF重写程序放到子进程中执行，好处如下：
- 子进程进行AOF重写期间，服务器进程(父进程)可以继续处理其它客户端请求。
- 子进程带有父进程的数据副本，使用子进程而不是线程，可以避免使用锁的情况下，保证数据的安全性。
子进程中AOF重写导致的问题：
- 子进程在进行AOF重写期间，服务器进程依然可以处理其它客户端请求，这就导致数据库状态已经发生了改变，使得当前数据库状态和重写后的AOF文件中的数据不一致。
数据状态不一致的解决方法：
- Redis服务器设置了一个AOF重写缓冲区。这个缓存区在创建子进程后开始使用，当Redis服务器执行一个客户端的写请求命令，之后将这个写命令也发送到AOF重写缓冲区。
- 当子进程完成AOF日志重写之后，给父进程发送信号，父进程接收此信号后，将AOF重写缓冲区的内容写到新的AOF文件中，保持数据一致性。

优缺点分析：
- AOF文件可以做到**秒级持久化**，使用追加写的方式来写入，**可读性强**并且可以使用命令进行文件修复。
- 相比于RDB文件，同样数据下AOF文件体积要大。在Redis负载较高时，秒级更新AOF文件会影响性能。

持久化策略选择：
- AOF更安全，可将数据及时同步到文件中，**但需要较多的磁盘I/O**，AOF文件尺寸教导，**文件内容恢复相对较慢也更加完整**。
- RDB持久化，**安全性较差**，它是正常时期数据备份及Mater-Slave数据同步的最佳手段，**文件尺寸较小**并且**恢复速度快**。

## Redis数据的过期回收策略与内存淘汰机制
Redis中数据过期回收策略使用了**定期删除**和**惰性删除**相结合的方式。
### 定期删除
Redis会每隔一定的时间去抽查一定量的数据判断其是否过期，过期则进行删除。
### 惰性删除：
在获取一个Key的时候，会判断这个Key是否过期了，如果过期，则进行删除。
### 内存淘汰机制
在配置文件中，可以对内存淘汰机制进行配置。当内存使用达到最大值时，Redis可以使用的**清除策略**如下：
- volatile-lru：利用LRU算法移除设置过过期时间的Key。
- allykeys-lru：利用LRU算法移除任何Key。
- volatile-random：随机移除设置过过期时间的Key。
- allkeys-random：随机移除key。
- volatile-ttl：移除即将过期的Key(minor TTL)。
- noeviction：不移除任何key，只是返回一个写错误，默认选项。

## Redis主从复制机制
当项目较大的时候，可以使用**主从架构Master/Slave机制**，Master以写为主，Slave以读为主，Master主节点更新后更新配置，自动同步到从机Slave节点。
主从复制的原理包括**旧版同步**和**命令传播**，主从复制的代价就是**系统复制较重**的时候会导致**主从延迟**，并且根据CAP理论，无法同时保证服务器可用性和数据一致性。
### CAP理论
CAP分别指：Consistent一致性，Availability可用性和Partition tolerance分区容忍度。CAP理论是指当网络分区发生时，一致性和可用性不可能同时保证。
网络分区：分布式系统的节点往往都是分布在不同机器上进行网络隔离的，这意味着必然会有网络断开的风险，网络断开也就意味着发生了网络分区。
最终一致性：Redis可以保证最终一致性，从节点会努力追赶主节点，最终从节点的状态会和主节点的状态保持一致。

## Redis对事务支持
事务的四大特性：ACID，原子性，一致性，隔离性，持久性。持久性是通过RDB和AOF实现的。
隔离性：Redis是单线程的程序，不会对事务进行中断。
操作事务的相关命令：
- MULTI：标记一个事务块的开始。
- EXEC：执行所有事务块内的命令。
- DISCARD：取消事务，放弃执行事务块内的所有命令。
- UNWATCH：取消WATCH命令对所有key的监视。
- WATCH key [key ...]：监视一个(或多个)key，如果在事务执行之前这个(或这些)key被其他命令所改动，那么事务将被打断。

Redis的事务不支持回滚操作。