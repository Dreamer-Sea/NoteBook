# Redis数据库
[toc]

## Redis是单线程的吗？为什么执行速度那么快？
是单线程，这里的单线程是指网络请求模块使用了一个线程，所以不需考虑并发安全性。但是对于需要依赖多个操作的复合操作来说，还是需要锁的，而且有可能是分布式锁。
### 为什么快？
- 基于**内存实现**，完全内存计算。
- 单线程操作，**避免了线程上下文切换操作**。
- **多路I/O复用的线程模型**，实现了一个线程监控多个I/O流，及时响应请求。
- **对外部的依赖比较少**，属于轻量级内存数据库。
### 多路I/O复用机制
目前支持I/O多路复用的系统调用有**select、pselect、poll、epoll**等函数。I/O多路复用就是通过一种机制**一个进程可以监控多个描述符**，一旦某个描述符读/写就绪，其能够通知应用程序进行相应的读写操作。该技术相比多进程和多线程来说，系统开销小，不必创建进程/线程，所以也不用维护这些进程/线程，从而大大减小了系统的开销。

## 使用Redis可能出现的问题
### 缓存雪崩
具体情况：缓存在同一时间大面积的失效，而这个时候又有一波对数据库的请求，请求过多导致数据库的连接异常。
解决方法：给缓存设置不同的失效时间，更新数据的时候使用互斥锁或者通过双缓存来避免缓存雪崩。
### 缓存穿透
具体情况：请求缓存中不存在的数据，导致请求直接去到了数据库上，导致数据库异常。
解决方法：可以使用互斥锁或者无论是否取到结果都将结果存入缓存，还可以使用有效的机制来拦截不合法的key值。
### 数据库和缓存的双写一致性问题
在高并发请求下很容易导致数据不一致的问题。在数据库中和缓存数据的删除或者写入过程中，如果有失败的情况，会导致数据的不一致。
解决方法：
- 双删延时：先删除缓存数据，然后更新数据库数据，最后再隔固定的时间再次删除缓存。
- 更新数据库产生的binlog订阅(使用canal)：将有变化的Key记录下来，并尝试不断地去删除缓存。

## Redis数据的过期回收策略与内存淘汰机制
Redis中数据过期回收策略使用了**定期删除**和**惰性删除**相结合的方式。
### 定期删除
Redis会每隔一定的时间去抽查一定量的数据判断其是否过期，过期则进行删除。
### 惰性删除：
在获取一个Key的时候，会判断这个Key是否过期了，如果过期，则进行删除。
### 内存淘汰机制
在配置文件中，可以对内存淘汰机制进行配置。当内存使用达到最大值时，Redis可以使用的**清除策略**如下：
- volatile-lru：利用LRU算法移除设置过过期时间的Key。
- allykeys-lru：利用LRU算法移除任何Key。
- volatile-random：随机移除设置过过期时间的Key。
- allkeys-random：随机移除key。
- volatile-ttl：移除即将过期的Key(minor TTL)。
- noeviction：不移除任何key，只是返回一个写错误，默认选项。

## Redis主从复制机制
当项目较大的时候，可以使用**主从架构Master/Slave机制**，Master以写为主，Slave以读为主，Master主节点更新后更新配置，自动同步到从机Slave节点。
主从复制的原理包括**旧版同步**和**命令传播**，主从复制的代价就是**系统复制较重**的时候会导致**主从延迟**，并且根据CAP理论，无法同时保证服务器可用性和数据一致性。
### CAP理论
CAP分别指：Consistent一致性，Availability可用性和Partition tolerance分区容忍度。CAP理论是指当网络分区发生时，一致性和可用性不可能同时保证。
网络分区：分布式系统的节点往往都是分布在不同机器上进行网络隔离的，这意味着必然会有网络断开的风险，网络断开也就意味着发生了网络分区。
最终一致性：Redis可以保证最终一致性，从节点会努力追赶主节点，最终从节点的状态会和主节点的状态保持一致。

## Redis对事务支持
事务的四大特性：ACID，原子性，一致性，隔离性，持久性。持久性是通过RDB和AOF实现的。
隔离性：Redis是单线程的程序，不会对事务进行中断。
操作事务的相关命令：
- MULTI：标记一个事务块的开始。
- EXEC：执行所有事务块内的命令。
- DISCARD：取消事务，放弃执行事务块内的所有命令。
- UNWATCH：取消WATCH命令对所有key的监视。
- WATCH key [key ...]：监视一个(或多个)key，如果在事务执行之前这个(或这些)key被其他命令所改动，那么事务将被打断。

Redis的事务不支持回滚操作。