# Redis

# 数据结构
Redis支持的数据结构有：
1. String
2. Hash
3. List
4. Set
5. Sorted Set (ZSet)

## Hash
Hash类似于Java中的HashMap，同样是**数组 + 链表**的组合。它同样需要Rehash，但是与HashMap不同，HashMap在进行Rehash的时候需要暂停HashMap支持的所有操作，Redis为了高性能，采取了渐进式的Rehash，即维持新旧两个Hash，在Hash的操作中逐步完成Rehash。在ReHash的过程中，查询操作会在两个Hash上同时进行。

Hash的value只能是字符串。

缺点：存储消耗大于单个字符串。

## List
List类似Java中的LinkedList，但是并不是一个简单的LinkedList，而是快速链表(QuickList)。在数据量小的时候，List中的元素会存放在连续的内存空间中，并且进行了压缩(ZipList)。当元素数量上来后，Redis就会将多个ZipList以LinkedList的方式连接起来。
List数据类型支持的lindex和ltrim需要对List进行遍历，所以属于慢操作。

## Set
Set可以看作特殊的Hash，即所有Set中的key的value都为NULL，而且key不存在重复。

## ZSet
Set的有序版本，在Set的基础上加入了Score字段来方便排序。底层数据结构是**跳跃列表**。



# 管道(Pipeline)
## 什么是RTT(Round Trip Time)
从发出端发出消息到发出端接收到接收端发出的确认消息之间的时间，被称为RTT。建立TCP连接需要经历2个RTT。

Redis是一种基于客户端-服务端模型(C/S模型)以及请求/响应协议的TCP服务。所以Redis在通常情况下发送一个请求会遵循以下步骤：
1. 客户端向服务端发送一个查询请求，并监听Socket返回，通常是以阻塞模式，等待服务端响应。
2. 服务端处理请求，并将结果返回给客户端。

**所以一般情况下Redis的每个命令都会经历一个请求(一个RTT)。**（可以类比HTTP 1.0协议中的短连接，即每次请求都会建立一个TCP连接。）

在以上的情况下，如果Redis执行大量的命令时就会耗费很多时间在RTT上。所以需要使用**管道**来解决这个问题。管道能够在一个请求中执行多于1条的命令，这样就能够大大的节省时间。

**缺点：**使用管道后，就要求服务端用一个回复队列来回复管道传递过来的命令，回复队列需要占用一定的内存空间，所以当客户端发送过来的命令特别多的时候，就需要对命令进行合理的分组，不然服务端就需要用很大的内存空间来存放回复队列。

# 发布/订阅
发布/订阅能让Redis实现1:N的消息传递。
每次订阅/取消订阅能够处理1个或多个频道。也能订阅/取消订阅一组满足特定模式的频道。
```
# 订阅频道
SUBSCRIBE channel_name

# 往频道中发布消息
PUBLISH channel_name message
```

# 内存优化
## 对小的聚合类型数据采用特殊的编码处理
这种方式一般能节省5倍以上的内存，只需要在配置文件(redis.conf)文件中配置各个聚合类型的阈值就行。当集合中的元素或元素数量大于等于某个值时，Redis就会自动把集合转换为正常的散列表。
## 使用32位的Redis
在32位的Redis下，key占用更少的内存。
## 位级别和字级别的操作
使用位操作的命令，将字符串当作随机操作的字节数组操作。
## 尽可能使用散列表(hashes)
使用小散列表。
## 内存分配
给Redis设置最大内存。

# 将Redis当作LRU算法的缓存
给Redis设置最大内存后，如果允许使用的内存不足了就会采取回收策略对内存进行回收。Redis采用的是近似LRU算法，只对部分key进行采样。
## 回收策略
1. noeviction：返回错误。
2. allkeys-lru：对所有的key采取LRU算法。
3. volatile-lru：对过期集合中的key采取LRU算法。
4. allkeys-random：随机回收所有key。
5. volatile-random：随机回收过期集合中的key。
6. volatile-ttl：优先回收过期集合中存活时间较短的key。

# 事务
事务是一组操作的组合，这组操作会按顺序执行。同时它也具有原子性，即这组操作要么都执行成功，要么都执行失败。
如果事务中有错误的操作，那么其它正确的操作会正常执行，错误的操作会被直接抛弃。
**WATCH**命令能够实现CAS。能够在多线程的情况下，保证value的一致性。

# 分区
Redis的分区，即将数据存放到不同Redis实例上。分区的意义在于分布式。
