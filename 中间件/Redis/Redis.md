# Redis

# SDS
Redis的底层使用C语言实现的。其中Redis中的字符串对象都是由SDS(Simple Dynamic String)，是由Redis创建的特殊字符串类型。
**SDS的数据结构**
```C
struct sdshdr{
	// 表示使用了多少字节
	int len;
	
	// 还剩多少字节能使用
	int free;
	
	// 字节数组，存储字符串的主体
	char buf[];
}
```
## SDS对比C语言中字符串的优点
1. 获取字符串长度的时间为O(1)。因为C语言的字符串**没有**记录字符串的长度。
2. 不会造成缓冲区溢出。SDS在修改字符串的时候会检查字节数组的大小。
3. SDS在修改字符串时进行**内存重分配**的次数少。SDS采用了**预分配**和**懒惰回收**来减少内存重分配。
4. SDS的主体是字节数组，能够存放二进制数据。
5. SDS只能使用**部分** \<string.h>库中的函数。

# 数据结构
Redis支持的数据结构有：
1. String
2. Hash
3. List
4. Set
5. Sorted Set (ZSet)
6. Bitmap
7. HyperLoglLog
8. 布隆过滤器
9. Geo
10. Stream

## Hash
Hash类似于Java中的HashMap，同样是**数组 + 链表**的组合。它同样需要Rehash，但是与HashMap不同，HashMap在进行Rehash的时候需要暂停HashMap支持的所有操作，Redis为了高性能，采取了渐进式的Rehash，即维持新旧两个Hash，在Hash的操作中逐步完成Rehash。在ReHash的过程中，查询操作会在两个Hash上同时进行。

Hash的value只能是字符串。

缺点：存储消耗大于单个字符串。

## List
List类似Java中的LinkedList，但是并不是一个简单的LinkedList，而是快速链表(QuickList)。在数据量小的时候，List中的元素会存放在连续的内存空间中，并且进行了压缩(ZipList)。当元素数量上来后，Redis就会将多个ZipList以LinkedList的方式连接起来。

List数据类型支持的lindex和ltrim需要对List进行遍历，所以属于慢操作。

## Set
Set可以看作特殊的Hash，即所有Set中的key的value都为NULL，而且key不存在重复。

## ZSet
Set的有序版本，在Set的基础上加入了Score字段来方便排序。底层数据结构是**跳跃列表**。

## BItmap
当存储二元数据的时候可以使用Bitmap而不是普通的key/value结构来存储。例如存储一个人一年(365天)的签到数据时，普通的key/value结构需要365个这样的数据结构，但是使用Bitmap只需要46个字节(1字节 = 8位，46字节 = 368位)。

Bitmap实际上是byte数组，操作的时候需要使用getbit/setbit等命令。

## HyperLogLog
该数据结构的主要操作有：pfadd和pfcount，前者往集合中添加数据，后者计算集合中数据的个数。pfmerge用来合并pfcount后的数据。当数据量很大的时候，pfcount存在误差。

## 布隆过滤器
该数据结构可以被视作**非精确的**set结构，这里的’非精确的’指的是当判断该数据类型的集合中是否存在某个对象时，可能出现误判。

布隆过滤器的错误率能够通过修改参数来降低。需要使用bf.reserve命令显式创建布隆过滤器，该命令有三个参数：key，error_rate和initial_size。error_rate越低，需要的空间越大。initial_size参数表示预计放入的元素数量，当实际数量超出这个数值时，**误判率会上升**。

## Geo
该数据结构能够存放地理信息，并且能够计算其中元素之间的距离。

该数据结构能够实现’附近的人‘的功能。

## Stream
主要用来当作消息队列的数据结构。能够在Stream上创建Consumer Group来消费其中的内容，Consumer Group的数量没有限制。每个Consumer Group上可以有多个Consumer，只要一个消息被Consumer Group中任意一个Consumer消费，就表示当前Consumer Group已经消费了这个消息。

# key的搜索
在Redis中搜索key可以用keys命令，但是该命令是返回所有的key，如果key的数量非常多，那么会造成Redis实例的暂停。

所以就有另一个搜索key的命令--scan。
scan的优点：
1. 搜索是用**游标**实现的，**不会阻塞**线程；
2. 能用limit参数，限制返回结果的最大条数；
3. 提供模式匹配功能；
4. 服务器不需要位游标**保存状态**；
5. 返回的结果**可能有重复**；
6. 在遍历的过程中如果有数据修改，改动后的数据能不能遍历时不确定的；
7. 单次返回的结果是空并不意味着遍历结束，而要看返回的游标值是否未零。

# 分布式锁
## 第一种：set命令 + lua脚本
在多线程的情况下，操作可能产生死锁，为了解决这个问题，set命令支持设置ex(expire，过期时间)和nx(“set if” not exists)。该命令是原子操作。
**获取锁**
```
# lock:codehole 只是一个普通的字符串
set lock:codehole true ex 5 nx
```
**释放锁**
```lua
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```
## 第二种：Redlock
前一种方式只是用运用在一个Redis节点的上，不适合主从方式的Redis。

** Redlock的使用**
假设现在有5个主节点，分别在5个服务器上。
1. 当客户端想要获得锁时，它会向这5个节点发送请求。请求超时时间一定要小于锁的失效时间；
2. 要求客户端的使用时间(当前时间 - 获得锁的时间)小于锁的失效时间，且有(N / 2 + 1)个节点都得到锁；
3. 如果获得锁成功，那么key的真正有效时间等于有效时间 - 获取锁所使用的时间。
4. 如果锁获取失败，那么客户端应该在所有的Redis实例上解锁。



# 延迟队列
Redis也能够使用**ZSet**聚合类型来实现延迟队列。将消息序列的**到期时间**作为ZSet中的**Score**。

# 管道(Pipeline)
## 什么是RTT(Round Trip Time)
从发出端发出消息到发出端接收到接收端发出的确认消息之间的时间，被称为RTT。建立TCP连接需要经历2个RTT。时间主要花费在**Read**操作中，因为**Read**操作需要等待响应信息的返回，而线程执行**Write**将消息写入操作系统的**发送缓存**中后，就去执行其它任务了。

Redis是一种基于客户端-服务端模型(C/S模型)以及请求/响应协议的TCP服务。所以Redis在通常情况下发送一个请求会遵循以下步骤：
1. 客户端向服务端发送一个查询请求，并监听Socket返回，通常是以阻塞模式，等待服务端响应。
2. 服务端处理请求，并将结果返回给客户端。

**所以一般情况下Redis的每个命令都会经历一个请求(一个RTT)。**（可以类比HTTP 1.0协议中的短连接，即每次请求都会建立一个TCP连接。）

在以上的情况下，如果Redis执行大量的命令时就会耗费很多时间在RTT上。所以需要使用**管道**来解决这个问题。管道能够在一个请求中执行多于1条的命令，这样就能够大大的节省时间。

**缺点：**使用管道后，就要求服务端用一个回复队列来回复管道传递过来的命令，回复队列需要占用一定的内存空间，所以当客户端发送过来的命令特别多的时候，就需要对命令进行合理的分组，不然服务端就需要用很大的内存空间来存放回复队列。

# 发布/订阅
发布/订阅能让Redis实现1:N的消息传递。
每次订阅/取消订阅能够处理1个或多个频道。也能订阅/取消订阅一组满足特定模式的频道。
```
# 订阅频道
SUBSCRIBE channel_name

# 往频道中发布消息
PUBLISH channel_name message
```

# 内存优化
## 对小的聚合类型数据采用特殊的编码处理
这种方式一般能节省5倍以上的内存，只需要在配置文件(redis.conf)文件中配置各个聚合类型的阈值就行。当集合中的元素或元素数量大于等于某个值时，Redis就会自动把集合转换为正常的散列表。
## 使用32位的Redis
在32位的Redis下，key占用更少的内存。
## 位级别和字级别的操作
使用位操作的命令，将字符串当作随机操作的字节数组操作。
## 尽可能使用散列表(hashes)
使用小散列表。
## 内存分配
给Redis设置最大内存。

# 将Redis当作LRU算法的缓存
给Redis设置最大内存后，如果允许使用的内存不足了就会采取回收策略对内存进行回收。Redis采用的是近似LRU算法，只对部分key进行采样。

## 回收策略
1. noeviction：返回错误。
2. allkeys-lru：对所有的key采取LRU算法。
3. volatile-lru：对过期集合中的key采取LRU算法。
4. allkeys-random：随机回收所有key。
5. volatile-random：随机回收过期集合中的key。
6. volatile-ttl：优先回收过期集合中存活时间较短的key。

# 事务
事务是一组操作的组合，这组操作会按顺序执行。同时它也具有原子性，即这组操作要么都执行成功，要么都执行失败。

如果事务中有错误的操作，那么其它正确的操作会正常执行，错误的操作会被直接抛弃。即Redis的事务**不具备原子性**。所以Redis不支持事务的回滚。

**WATCH**命令能够实现CAS。能够在多线程的情况下，保证value的一致性。

# 主从同步
## 分布式系统的理论基石
CAP原理：
1. C -- Consistent 一致性；
2. A - Availability 可用性；
3. P -- Partition tolerance 分区容忍性

## 一致性
Redis只保证**最终一致性**，即主从节点并不是时时刻刻都保证一致性的，主从节点存在一定的差别，但是从节点会努力的赶上主节点。

## 主从同步
Redis的主从同步采取的是增量同步和快照同步。一般情况下使用增量同步，即主节点将修改性指令写入buffer，然后异步的将buffer中的指令发送给从节点。
如果buffer太小，可能导致最早进入buffer的指令在发送给从节点前就被新的指令覆盖。这是要就需要使用快照同步，即将主节点的全部内存数据快照到磁盘文件中，然后再将文件中的内容传送到从节点。在快照同步进行的过程中，buffer还是可能被覆盖，所以buffer太小可能出现快照同步的死循环中。

## 无盘复制
在进行快照同步的时候，可能对主节点带来很大的IO压力，这时候就能够通过套接字将快照内容发给从节点，即主节点边遍历内存，边将序列化的内容发送到从节点。

# 哨兵 (Sentinel)
在加入哨兵后，客户端想要连接节点就要经过哨兵。哨兵会监视主节点的状态，在主节点出问题时，立马在从节点中选择最优的作为新的主节点。

# 分区
Redis的分区，即将数据存放到不同Redis实例上。分区的意义在于分布式。

# 通讯协议
Redis的作者认为数据库系统的瓶颈一般不在网络流量，而在内部逻辑处理上，所以他在Redis上采用了浪费流量的文本协议--RESP(Redis Serialization Protocol)。

# 持久化
Redis支持两种持久化方式：
1. RDB(镜像，全局持久化)；
2. AOF(增量备份)。

## RDB
RDB这种备份方式是在主线程创建一个子进程，这个子进程对内存数据进行遍历且序列化到磁盘中。如果在RDB过程中，客户端执行了修改内存数据的命令，那么主进程会将需要修改的数据复制一份出来，对副本数据进行修改。

## AOF
这种备份方式不是序列化内存数据，而是存储Redis服务器的**顺序指令序列**。AOF文件中记录的是从Redis实例创建以来所有**修改性**指令序列。

AOF重写：因为AOF可能存在大量重复的命令。开辟一个子进程对内存进行遍历转换成一系列Redis的操作指令，并将这些操作指令序列化到一个新的AOF日志文件中，这样能够合并重复的操作指令。序列化完后，再将序列化期间的增量AOF日志追加到这个新的AOF文件中。

fsync：Redis在运行中可能因为意外而退出，这可能导致AOF操作失败。所以在Linux在提供了fsync函数，能够将指定文件的内容强制从内核缓存刷到磁盘。一般选择1秒执行一次fsync函数。

## 混合持久化
RDB需要遍历全部内存，大块写磁盘会加重系统负载；AOF的fsync是一个耗时的IO操作，它会降低Redis性能，同时也会增加系统IO负担。
在Redis 4.0中采用混合持久化的方式，在Redis重启的时候，先加载RDB的内容，然后重放增量AOF日志。

# Cluster
每个节点负责整个集群中的一部分数据。
## 槽位定位算法
hash(crc32(key))
## 跳转
当客户端向错误的节点发出了指令，那么节点就会向客户端发送‘MOVED’指令，告诉客户端正确的节点地址。
## 签移
Redis Cluster运行运维人员手动调整槽位分配情况。

