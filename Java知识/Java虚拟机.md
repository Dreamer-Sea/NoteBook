# Java虚拟机(JVM， Java Virtual Machine)
[toc]

JVM是一类虚拟机的统称，在Java开发中使用的JVM实现是HotSpot虚拟机。

## Java在运行时的数据区域(Java的内存结构)
共享部分：堆，方法区(其中有运行时常量池)。
独占部分：程序计数器，虚拟机方法栈，本地方法栈。
以上这些区域的划分是根据Java文档来的，但是在JVM的具体实现中未必是这么划分的。
在HotSpot虚拟机中，及JDK 1.8 之前，方法区的实现就是永久代，而永久代在堆上。在JDK 1.8之后，方法区被取消了，取而代之的是元空间。同时在JDK 1.8之后，虚拟机方法栈和本地方法栈被合并了。

## 类加载
### 类加载机制
加载 ->  连接(验证 -> 准备 -> 解析) -> 初始化
- 加载：
    - 获取类的二进制字节流；
	- 将字节流(静态存储结构)转换为**方法区**的运行时数据结构；
	- 在内存(堆)中生成一个代表该类的Class对象，作为方法区这些数据的访问入口。
- 连接：
    - 验证：
        - 文件格式验证；
        - 元数据验证；
        - 字节码验证；
        - 符号引用验证。
    - 准备：为类变量分配内存并设置类变量初始值的阶段，这些内存都在方法区中分配。
    - 解析：虚拟机将常量池内的符号引用替换为直接引用的过程。
- 初始化：执行类构造器<clinit>()方法的过程。


### Class对象的存放位置
在较早的版本中，类对象是静态的(基本没人用自定义类加载器，以及类被加载后不会被卸载)，Java的一般对象和Java的Class对象都存放在一起(没有永久代)，即都存放在堆上。
但因为新的垃圾收集器的出现(Parallel Scavenge)，使得一个独立的永久代(PermGen，Permanent Generation)的存在是必要的。

**补充1：**方法区中存放有什么？
- Klass系对象；
- java.lang.Class对象；
- 字符串常量；
- 符号（Symbol/symbolOop）常量；
- 常量池对象；
- 方法对象；
- 等等。

** 补充2：**永久代的变更历程。
Java 6：方法区中包含的数据，除了JIT编译生成的代码放在native memory的CodeCache中外，其它的都在永久代中。
Java 7：Symbol的存储从永久代移到了native memory中；把静态变量从instanceKlass末尾(PermGen中)移到了java.lang.Class对象的末尾(位于普通Java堆中)。
Java 8：永久代被移除，用元空间(Metaspace)取代。

### 类加载器
JVM自带的类加载器有三种：AppClassLoader，ExtClassLoader，BootStrapClassLoader。同时用户能够自定义类加载器。
自定义加载器的意义之一，就是实现Java的热部署。使用自定义的类加载器来加载需要热部署的类，通过销毁类加载器，能够销毁有这个类加载器加载的类，然后更新类，再使用新的类加载器去加载更新后的类(**问题：1，既然类更新了，类加载器需要进行什么操作？**)。

#### 如何实现自定义类加载器
继承java.lang.ClassLoader类，重写findClass(String name)方法。

### 类的加载方式
双亲委派模型。该模型保证每个基础类仅加载一次，使得JVM中不存在重名的类。提高了Java的安全与稳定性。