# Java虚拟机(JVM， Java Virtual Machine)
[toc]

JVM是一类虚拟机的统称，在Java开发中使用的JVM实现是HotSpot虚拟机。

## Java在运行时的数据区域(Java的内存结构)
共享部分：堆，方法区(其中有运行时常量池)。
独占部分：程序计数器，虚拟机方法栈，本地方法栈。
以上这些区域的划分是根据Java文档来的，但是在JVM的具体实现中未必是这么划分的。
在HotSpot虚拟机中，及JDK 1.8 之前，方法区的实现就是永久代，而永久代在堆上。在JDK 1.8之后，方法区被取消了，取而代之的是元空间。同时在JDK 1.8之后，虚拟机方法栈和本地方法栈被合并了。

## 类加载
### 类加载机制
加载 ->  连接(验证 -> 准备 -> 解析) -> 初始化
- 加载：
    - 获取类的二进制字节流；
	- 将字节流(静态存储结构)转换为**方法区**的运行时数据结构；
	- 在内存(堆)中生成一个代表该类的Class对象，作为方法区这些数据的访问入口。
- 连接：
    - 验证：
        - 文件格式验证；
        - 元数据验证；
        - 字节码验证；
        - 符号引用验证。
    - 准备：为类变量分配内存并设置类变量初始值的阶段，这些内存都在方法区中分配。
    - 解析：虚拟机将常量池内的符号引用替换为直接引用的过程。
- 初始化：执行类构造器<clinit>()方法的过程。


### Class对象的存放位置
在较早的版本中，类对象是静态的(基本没人用自定义类加载器，以及类被加载后不会被卸载)，Java的一般对象和Java的Class对象都存放在一起(没有永久代)，即都存放在堆上。
但因为新的垃圾收集器的出现(Parallel Scavenge)，使得一个独立的永久代(PermGen，Permanent Generation)的存在是必要的。

**补充1：**方法区中存放有什么？
- Klass系对象；
- java.lang.Class对象；
- 字符串常量；
- 符号（Symbol/symbolOop）常量；
- 常量池对象；
- 方法对象；
- 等等。

** 补充2：**永久代的变更历程。
Java 6：方法区中包含的数据，除了JIT编译生成的代码放在native memory的CodeCache中外，其它的都在永久代中。
Java 7：Symbol的存储从永久代移到了native memory中；把静态变量从instanceKlass末尾(PermGen中)移到了java.lang.Class对象的末尾(位于普通Java堆中)。
Java 8：永久代被移除，用元空间(Metaspace)取代。

### 类加载器
JVM自带的类加载器有三种：AppClassLoader，ExtClassLoader，BootStrapClassLoader。同时用户能够自定义类加载器。
自定义加载器的意义之一，就是实现Java的热部署。使用自定义的类加载器来加载需要热部署的类，通过销毁类加载器，能够销毁有这个类加载器加载的类，然后更新类，再使用新的类加载器去加载更新后的类(**问题：1，既然类更新了，类加载器需要进行什么操作？**)。

#### 如何实现自定义类加载器
继承java.lang.ClassLoader类，重写findClass(String name)方法。

### 类的加载方式
双亲委派模型。该模型保证每个基础类仅加载一次，使得JVM中不存在重名的类。提高了Java的安全与稳定性。

## 对象的内存分配
- 指针碰撞：使用标记-整理GC算法。堆内存是规整的。用过的内存在一边，未使用的内存在另一边，中间用一个指针分隔。
- 空闲列表：使用标记-清除GC算法。堆内存是不规整的。JVM会维护一个列表，列表会记录哪些内存块未被使用。

## 内存的分配如何保证线程安全
- CAS + 失败重试保证更新指针操作的原子性。
- 给每个线程预先分配一定的内存(本地线程分配缓存，TLAB)。当预分配的TLAB用完在分配新的TLAB是，才需要进行同步锁定。

## 对象被访问的时候是怎么被找到的？
当对象被创建之后，在栈内存中会有一个引用变量，这个引用变量会指向堆内存中的某个具体的对象实例。
### 常见的对象的访问方式
- 句柄：在堆内存中开辟一块内存空间来作为句柄池，在引用变量中存储的就是对象的句柄地址，地址中包含了对象实例数据与类型各自的具体地址信息。在GC后，对象会被移动，但是引用中存储的是稳定的句柄地址。这个方式的访问速度比较慢。
- 直接指针：引用变量中存储的就是对象的直接地址，访问速度较快。Sun HotSpot虚拟机使用了该方式进行对象的访问。

## 动态对象年龄判断
如果Survivor空间中相同年龄所有对象的大小总和大于Surviror空间的一半，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值。

## 如何判断一个对象是否应该被回收
两种判断方法：
- 引用计数法：对象存在引用，则引用计数不为0，
- root根搜索法(可达性分析)：

## 引用：
- 强引用：永远不可回收的对象。
- 软引用：内存空间不够的时候就会被回收。
- 弱引用：只要执行GC就一定会被回收。
- 软引用：只是为了对象被回收时候收到一个系统通知。

## 垃圾回收(Garbage Collcetion, GC)

### 垃圾回收算法
#### 标记-清除算法
标记要不需要回收的对象，然后将未标记的对象清除。该算法容易产生内存碎片。
#### 复制算法
将内存空间划分为两个相等的区域，每次只使用其中一个区域。发生GC时，遍历使用的区域，将正在使用的对象复制到另一个未使用的区域中，并且进行相应的内存整理。减少了内存空间的利用率。
#### 标记-整理算法
GC时，标记所有引用对象，然后清除未标记的对象，并将标记的对象进行整理，使它们在内存中顺序排放。结合了标记-清除算法和复制算法的优点。
#### 分代算法
新生代用复制算法，老生代用标记-清除算法/标记-整理算法。

### 垃圾收集器
- Serial收集器：在**Client模式**下，**新生代**默认使用的收集器。单线程执行。在GC时需要**Stop the world(停止其它任务来进行GC)**。简单高效，没有多线程交互的开销。
- Serial Old收集器：针对**老年代**的单线程收集器。在**Server模式**下作为CMS垃圾收集器的后备预案，在CMS并发收集发生**Concurrent Mode Failure**时使用。
- ParNew收集器：Serial收集器的**多线程**版本，新生代时并行的(多线程的)，老年代是串行的(单线程的)，新生代采用**复制算法**，老年代采用**标记-整理算法**。
- Parallel Scavenge收集器：一种针对**新生代**的**多线程**收集器。该收集器**更加关注吞吐量**。**-XX:MaxGCPauseMillis(设置垃圾收集停顿的最大时间)**，**-XX:GCTimeRatio(设置吞吐量大小)**，**-XX:UseAdaptiveSizePolicy(打开GC自适应调节参数)**。
- Parallel Old收集器：该收集器是Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法。
- CMS(Concurrent Mark Sweep)收集器：一种以获取**最短回收停顿时间为目标**的收集器，使用**标记-清除算法**，是一种老年代收集器，通常与ParNew一起使用。
- G1(Garbage-First)收集器：

#### CMS(Concurrent Mark Sweep)收集器
收集过程：
- **初始标记：**‘Stop the World’，仅仅只是标记以下GC Root能够直接关联到的对象，速度快。
- **并发标记：**主要的标记过程，与用户线程并发执行。
- **重新标记：**‘Stop the World’，修正前一阶段标记产生变动的那一部分对象的标记记录(停顿时间比初始标记长，但比并发标记短得多)。
- **并发清除：**与用户线程并发执行，基于标记结果来清理对象。

优点：能够并发收集，停顿时间低。
缺点：
- **对CPU资源敏感**(与用户线程并行，争夺CPU资源)。
- 收集过程种会产生**浮动垃圾**。浮动垃圾需要占用内存(一般为20%)，如果**-XX:CMSInitiatingOccupancyFraction**设置的百分比太高，那么在CMS进行GC期间，内存大小不够GC线程和用户线程并发运行，就会出现**Concurrent Mode Failure**，接着JVM就会用Serial Old收集器作为老年代收集器，这回产生更长的停顿时间。
- 标记-清除算法会产生内存碎片：

**浮动垃圾：**由于在GC过程中，用户线程会与GC线程并发运行，那么有些垃圾就有可能在GC完成时产生，这些垃圾需要在下次GC才能够被回收掉。

#### G1(Garbage-First)收集器
该收集器**将堆内存划分为若干的区域**，一部分区域为新生代，采用复制算法，另一部分区域为老生代，采用标记-整理算法。G1跟踪各个区域里的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值)，在后台维护一个优先列表，每次**根据回收时间来优先回收价值最大的区域**。

特点：
- 并行与并发：充分利用多CPU，多核环境来缩短Stop the World。
- 分代回收：仅用一个收集器就能够用不同的方式去处理新建对象，存活一段时间的对象和熬过多次GC的对象。
- 空间整合：整体上是**标记-整理算法**，局部是**复制算法**，避免了内存空间碎片的产生。
- 可预测的停顿：能够建立可以预测的停顿时间模式，预测停顿时间(**G1跟踪每个区域的价值**)。

过程：
- 初始标记：
- 并发标记：
- 最终标记：
- 筛选回收：首先对各个区域的回收价值和成本进行计算，根据用户期望的GC停顿时间来制定回收计划。

