# Java虚拟机(JVM， Java Virtual Machine)
[toc]

JVM是一类虚拟机的统称，在Java开发中使用的JVM实现是HotSpot虚拟机。

# Java在运行时的数据区域(Java的内存结构)
共享部分：堆，方法区(其中有运行时常量池)。
独占部分：程序计数器，虚拟机方法栈，本地方法栈。
以上这些区域的划分是根据Java文档来的，但是在JVM的具体实现中未必是这么划分的。
在HotSpot虚拟机中，及JDK 1.8 之前，方法区的实现就是永久代，而永久代在堆上。在JDK 1.8之后，方法区被取消了，取而代之的是元空间。同时在JDK 1.8之后，虚拟机方法栈和本地方法栈被合并了。
## 各部分的介绍
- 程序计数器：程序控制流计数器，分支、循环、跳转、异常处理、线程恢复等基础功能都依赖这个计数器。**执行本地方法时，该计数器未空(Undefined)。**该内存区域不存在OOM情况。
- 虚拟机方法栈：当执行Java方法的时候，就会创建一个栈帧放入该栈中。栈帧内包括：**局部变量表**、**操作数栈**、**动态连接**、**方法出口**等信息。方法执行完后，对应的栈帧就会出栈。局部变量表中的数据可以为**基本数据类型**、**对象引用(指向对象起始地址的指针、句柄或与对象相关的位置)**、**returnAddress类型(指向了一条字节码指令的地址)**；局部变量表中的存储空间以局部变量槽(Slot)来表示，long和double类型会占用两个槽。
- 本地方法栈：与虚拟机方法栈类似，但是服务的对象是本地方法。在HotSpot虚拟机中，虚拟机方法栈和本地方法栈被合二为一了。
- 堆：内存区域最大的一块，唯一目的就是存放**实例对象**。所有的对象实例以及数组都应当在堆上分配(**未来，基本数据类型也可能在堆上分配**)。堆内存的分区(**内存分代**)是由分代垃圾收集器来的。
- 方法区：用来存储已被虚拟机加载的**类型信息**、常量、静态变量、即时编译器编译后的代码缓存等数据。**在HotSpot虚拟机中JDK 8之前，用永久代来实现了方法区的功能，而永久代这一术语是与堆内存分代相关联的。这样使得垃圾收集器能够管理方法区的内存。在JDK 8中，永久代被元空间取代了，元空间是在主内存中。**方法区内存的回收主要是**常量池的回收**和**类型的卸载**。
- 运行时常量池：该部分是方法区的一部分，该部分用来存放编译期生成的各种**字面量**与**符号引用**。
### 栈溢出(StackOverflowError)和内存溢出(OutOfMemoryError)
- 栈溢出：线程请求的栈深度大于虚拟机所允许的深度，就会抛出该异常。
- 内存溢出：如果Java虚拟机栈容量可以**动态扩展**，当栈扩展时无法申请到足够的内存就会抛出该异常。

# 对象的创建
在JVM中创建对象需要经过以下几个过程：检查类是否被加载、解析和初始化过 -> 给新生对象分配内存 -> 初始化被分配的内存空间 -> 设置对象头 -> 执行初始化方法 < init >。

- 检查类是否被加载、解析和初始化过：检查是否能够在常量池中定位到需要的类的符号引用，接着检查该类是否被加载、解析和初始化过，如果没有则需要执行相应的类加载过程。
- 给新生对象分配内存：在类加载之后，就能够确定对象需要多大的内存空间。
- 初始化被分配的内存空间：除了对象头外，给其他初始化零值。
- 设置对象头：设置对象的信息，该对象属于哪个类、类的元信息在哪、哈希码、GC分代年龄等信息。
- 执行初始化方法< init >：执行Class文件的< init >()方法。

## 内存分配方式
在Java堆上给新生对象分配内存的方式有2中。一种是“指针碰撞”，另一个是“空闲列表”，区分的依据是根据内存空间是否规则而来的。
- 指针碰撞：内存空间规整。已使用的内存空间和未使用的内存空间被一个指针区分开。内存分配就是指针向未使用内存空间移动的过程。
- 空闲列表：内存空间不规整。虚拟机维护一个列表，列表中记录了哪些内存空间是空闲的，哪些是非空闲的。

## 内存分配的安全性问题
- CAS+失败重试；
- 预先给每个线程在堆上分配一小块空间(本地线程分配缓冲，TLAB)，在TLAB空间足够时，内存的分配在各个线程的TLAB上进行，当TLAB不够时，才会同步锁定。

## 对象的内存布局
对象在堆内存中的存储布局可以分为**对象头**、**实例数据**和**对齐填充**这三个部分。
- 对象头：该部分存放以下内容：哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。
- 实例数据：HotSpot虚拟机默认的分配顺序：longs/doubles、ints、shorts/chars、bytes/booleans、oops。
- 对齐填充：对象的大小必须是8字节的整数倍。

## 对象的访问定位
根据栈中的reference数据存放的是对象的句柄还是直接指向对象的指针，将对象的访问方式分为2种。
- 句柄访问：堆内存中开辟一块内存(句柄池)用来存放句柄，句柄存放了对象的实例数据(Java堆中)和类型数据(方法区中)。对象发生移动时，reference不变，只改变对象的实例数据指针。
- 直接指针访问：reference中存储的是对象的实例数据，当只需要访问对象的实例数据时，该方式更快。

# 类加载
## 类加载机制
加载 ->  连接(验证 -> 准备 -> 解析) -> 初始化
- 加载：
    - 获取类的二进制字节流；
	- 将字节流(静态存储结构)转换为**方法区**的运行时数据结构；
	- 在内存(堆)中生成一个代表该类的Class对象，作为方法区这些数据的访问入口。
- 连接：
    - 验证：
        - 文件格式验证；
        - 元数据验证；
        - 字节码验证；
        - 符号引用验证。
    - 准备：为类变量(静态成员)分配内存并设置类变量初始值的阶段，这些内存都在方法区中分配。
    - 解析：虚拟机将常量池内的符号引用替换为直接引用的过程(例如类继承，接口实现)。
- 初始化：执行类构造器< clinit >()方法的过程。

## Class对象的存放位置
在较早的版本中，类对象是静态的(基本没人用自定义类加载器，以及类被加载后不会被卸载)，Java的一般对象和Java的Class对象都存放在一起(没有永久代)，即都存放在堆上。
但因为新的垃圾收集器的出现(Parallel Scavenge)，使得一个独立的永久代(PermGen，Permanent Generation)的存在是必要的。

**补充1：**方法区中存放有什么？

- Klass系对象；
- java.lang.Class对象；
- 字符串常量；
- 符号（Symbol/symbolOop）常量；
- 常量池对象；
- 方法对象；

**补充2：**永久代的变更历程。
Java 6：方法区中包含的数据，除了JIT编译生成的代码放在native memory的CodeCache中外，其它的都在永久代中。
Java 7：Symbol的存储从永久代移到了native memory中；把静态变量从instanceKlass末尾(PermGen中)移到了java.lang.Class对象的末尾(位于普通Java堆中)。
Java 8：永久代被移除，用元空间(Metaspace)取代。

## 类加载器
JVM自带的类加载器有三种：AppClassLoader，ExtClassLoader，BootStrapClassLoader。同时用户能够自定义类加载器。
自定义加载器的意义之一，就是实现Java的热部署。使用自定义的类加载器来加载需要热部署的类，通过销毁类加载器，能够销毁有这个类加载器加载的类，然后更新类，再使用新的类加载器去加载更新后的类(**问题：1，既然类更新了，类加载器需要进行什么操作？**)。

### 如何实现自定义类加载器
继承java.lang.ClassLoader类，重写findClass(String name)方法。

## 类的加载方式
双亲委派模型。该模型保证每个基础类仅加载一次，使得JVM中不存在重名的类。提高了Java的安全与稳定性。

# 对象的内存分配
- 指针碰撞：使用标记-整理GC算法。堆内存是规整的。用过的内存在一边，未使用的内存在另一边，中间用一个指针分隔。
- 空闲列表：使用标记-清除GC算法。堆内存是不规整的。JVM会维护一个列表，列表会记录哪些内存块未被使用。

# 内存的分配如何保证线程安全
- CAS + 失败重试保证更新指针操作的原子性。
- 给每个线程预先分配一定的内存(本地线程分配缓存，TLAB)。当预分配的TLAB用完在分配新的TLAB是，才需要进行同步锁定。

# 对象被访问的时候是怎么被找到的？
当对象被创建之后，在栈内存中会有一个引用变量，这个引用变量会指向堆内存中的某个具体的对象实例。
## 常见的对象的访问方式
- 句柄：在堆内存中开辟一块内存空间来作为句柄池，在引用变量中存储的就是对象的句柄地址，地址中包含了对象实例数据与类型各自的具体地址信息。在GC后，对象会被移动，但是引用中存储的是稳定的句柄地址。这个方式的访问速度比较慢。
- 直接指针：引用变量中存储的就是对象的直接地址，访问速度较快。Sun HotSpot虚拟机使用了该方式进行对象的访问。

# 动态对象年龄判断
如果Survivor空间中相同年龄所有对象的大小总和大于Surviror空间的一半，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值。
