# 经典垃圾收集器
[toc]

## Serial收集器
在**Client模式**下，**新生代**默认使用的收集器。单线程执行。在GC时需要**Stop the world(停止其它工作线程来进行GC)**。简单高效，没有多线程交互的开销。
缺点：严重影响**用户体验**。因为每隔一段时间就需要进行一次GC，在GC的时候其它的工作都不能进行。
优点：简单、高效、占用内存少，适合微服务应用。
## Serial Old收集器
针对**老年代**的单线程收集器。在**Server模式**下作为CMS垃圾收集器的后备预案，在CMS并发收集发生**Concurrent Mode Failure**时使用。
## ParNew收集器
Serial收集器的**多线程**版本。在经典的垃圾收集器中，只有该垃圾收集器能够与CMS垃圾收集器配合工作(前者负责新生代，后者负责老年代)。
缺点：在单核处理器中，一定不比Serial垃圾收集器强，甚至因为需要进行上下文切换，所以性能在伪双核处理器中可能会比Serial收集器更差。
优点：随着处理器核心的增加，该收集器的价值才愈发能体现出来。该收集器的默认线程数与处理器的线程数一致。
## Parallel Scavenge收集器
一种针对**新生代**的**多线程**收集器。该收集器**更加关注吞吐量**。这里是说Parallel Scavenge收集器在乎的是可控的吞吐量，而不是最少的用户线程停顿时间。**-XX:MaxGCPauseMillis(设置垃圾收集停顿的最大时间)**，**-XX:GCTimeRatio(设置吞吐量大小)**，**-XX:UseAdaptiveSizePolicy(打开GC自适应调节参数)**。
吞吐量：**吞吐量 = 运行用户代码的时间 / (运行用户代码时间 + 运行垃圾收集时间)**
## Parallel Old收集器
该收集器是Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法。

## CMS(Concurrent Mark Sweep)收集器

一种以获取**最短回收停顿时间为目标**的收集器，使用**标记-清除算法**，是一种老年代收集器，通常与ParNew一起使用。

收集过程：
- **初始标记：**‘Stop the World’，仅仅只是标记GC Roots能够直接关联到的对象，速度快。
- **并发标记：**主要的标记过程，与用户线程并发执行。**耗时长**。
- **重新标记：**‘Stop the World’，修正前一阶段标记产生变动的那一部分对象的标记记录(停顿时间比初始标记长，但比并发标记短得多)。
- **并发清除：**与用户线程并发执行，基于标记结果来清理对象。

优点：能够**并发**收集，**停顿时间低**。
缺点：

- **对CPU资源敏感**(与用户线程并行，争夺CPU资源)。
- 收集过程种会产生**浮动垃圾**。浮动垃圾需要占用内存(一般为20%)，如果**-XX:CMSInitiatingOccupancyFraction**设置的百分比太高，那么在CMS进行GC期间，内存大小不够GC线程和用户线程并发运行，就会出现**Concurrent Mode Failure**，接着JVM就会用Serial Old收集器作为老年代收集器，这回产生更长的停顿时间。
- 标记-清除算法会产生内存碎片：

**浮动垃圾：**由于在GC过程中，用户线程会与GC线程并发运行，那么有些垃圾就有可能在GC完成时产生，这些垃圾需要在下次GC才能够被回收掉。

## G1(Garbage-First)收集器
该收集器**将堆内存划分为若干的区域**，一部分区域为新生代，采用复制算法，另一部分区域为老生代，采用标记-整理算法。G1跟踪各个区域里的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值)，在后台维护一个优先列表，每次**根据回收时间来优先回收价值最大的区域**。

特点：
- 并行与并发：充分利用多CPU，多核环境来缩短Stop the World。
- 分代回收：仅用一个收集器就能够用不同的方式去处理新建对象，存活一段时间的对象和熬过多次GC的对象。
- 空间整合：整体上是**标记-整理算法**，局部是**复制算法**，避免了内存空间碎片的产生。
- 可预测的停顿：能够建立可以预测的停顿时间模式，预测停顿时间(**G1跟踪每个区域的价值**)。
- 使用两个名为TAMS(Top at Mark Start)指针划分一定的内存空间来存放并发回收时新对象的分配。
- 使用**衰减平均值**作为停顿预测模型的理论基础，预测由哪些Region组成的会收集才能在不超过期望停顿时间的约束下获得最高收益。
- 使用**STAB(原始快照算法)**记录并发过程中发生变动的对象。

过程：
- 初始标记：标记GC Roots的可达对象。修改TAMS指针的值，使其在GC过程中能够继续分配新对象。
- 并发标记：从GC Roots开始对堆中对象进行**可达性分析**，
- 最终标记：
- 筛选回收：首先对各个区域的回收价值和成本进行计算，根据用户期望的GC停顿时间来制定回收计划。

缺点：

- G1收集器至少要消耗大约相当于Java堆容量的**10%**到**20%**的额外内存来维持收集器工作。