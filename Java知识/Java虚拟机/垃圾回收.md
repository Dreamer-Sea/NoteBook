# 对象回收(垃圾回收，GC)
[toc]

Java对象的回收是发生在堆内存(包括方法区)上的，因为程序计数器、虚拟机方法栈和本地方法栈的生命周期与它们所在的线程的生命周期一致，当线程终止时，它们占用的内存也会释放。

## 如何判断一个对象是否应该被回收
判断方法有2种，其中：
- 引用计数法：对象存在引用，则引用计数不为0，
- 可达性分析：从一系列GC Roots的根对象作为起始节点集出发，根据引用关系向下搜索，如果从GC Roots到某个对象是不可达的(图论中的概念)，那么该对象就有可能被回收。

## 哪些对象也作为GC Roots？
- 局部变量表中引用的对象。
- 方法区中**静态属性**引用的对象。
- 方法区中**常量**引用的对象。
- 本地方法栈中**JNI(即通常所说的Native方法)**引用的对象。
- Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象(比如NullPointException，OutOfMemoryError)等，还有系统类加载器。
- **所有被同步锁(synchronized关键字)**持有的对象。
- 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

## 引用
在JDK 1.2之后将引用的类型进行了扩展，从只有强引用类型到现在的四种引用类型。
- 强引用：永远不可回收的对象。
- 软引用：内存空间不够的时候就会被回收。
- 弱引用：只要执行GC就一定会被回收。
- 软引用：只是为了对象被回收时候收到一个系统通知。

## 对象的死亡
对象的死亡即意味着对象的回收，在满足什么样的条件下对象才会是可以回收的？
对象在经过两次标记后才会被认为是**可**回收的，第一次标记是该对象未被其它对象引用；第二次标记是判断该对象是否有必要执行**finalize()方法**。如果该对象没有覆盖finalize()方法、或finalize()方法已经被虚拟机调用过一次了，那么这两种情况都是没有必要执行finalize()方法。

## 方法区的垃圾收集
在方法区中主要回收两种垃圾：一个是废弃的常量，另一个是不再使用的类型。这两种垃圾只有满足以下条件才**可以**被回收。
- 废弃常量：只要没有对象的内容是该常量，那么该常量就会被回收。
- 不再使用类型：
	- 该类型的所有对象都被回收。
	- 加载该类的类加载器已经被回收。很难达成。
	- 该类对应的java.lang.Class对象没有在任何地方被引用。

## 垃圾回收算法
当前的商业虚拟机的垃圾收集器都遵循了“分代收集”的理论，而该理论优势基于两个分代假说之上的：
- 弱分代假说：绝大多数对象都是朝生夕灭的。
- 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。
### 标记-清除算法
标记要不需要回收的对象，然后将未标记的对象清除。该算法容易产生内存碎片。
### 复制算法
将内存空间划分为两个相等的区域，每次只使用其中一个区域。发生GC时，遍历使用的区域，将正在使用的对象复制到另一个未使用的区域中，并且进行相应的内存整理。减少了内存空间的利用率。
### 标记-整理算法
GC时，标记所有引用对象，然后清除未标记的对象，并将标记的对象进行整理，使它们在内存中顺序排放。结合了标记-清除算法和复制算法的优点。
### 分代算法
新生代用复制算法，老生代用标记-清除算法/标记-整理算法。

## 垃圾收集器