# 并发容器
[toc]

# 同步容器
与并发容器相对的是同步容器，同步容器是使用**synchronized关键字**来实现的，如果有多个线程调用同步容器的方法，它们将会串行执行。

# SynchronizedMap和ConcurrentHashMap的区别
- SynchronizedMap：
	- 一次锁住整张表来保证线程安全，所以每次只能由一个线程来访问Map。
- ConcurrentHashMap：
	- 使用分段锁来保证在多线程下的性能。
	- 如果使用iterator迭代时，Map的元素数量发生了改变，那么该数据类型会**new**一个新的对象作为修改后的Map，iterator还是迭代旧的Map，当iterator迭代完后才将头指针指向新的Map。

## ConcurrentHashMap的并发度
JDK 1.8前，该数据结构将Map分为16个部分，允许最多16个线程分别操作Map种的不同部分。
在1.8之后抛弃了Segment(锁段)的概念，而是使用了CAS算法 + 一些辅助变量。

# CopyOnWriteArrayList
## 原理
CopyOnWriteArrayList类的加锁实现是ReentrantLock，只有在写操作的时候会加锁，读操作不加锁。该类的底层数据结构是数组。在写操作的时候，该类会先生成一个当前数组的副本，然后对这个副本进行写操作，在写操作完成后，将数组对象指向新的数组。
## 问题
- 该类在获取元素的时候，是先找到底层数组(步骤A)，然后再根据下标去访问数组中的元素(步骤B)。如果该类在执行完步骤A后，有另外的线程执行了该类的remove操作，就会导致执行步骤B的时候，获得的元素不是预期的。即弱一致性问题。
- 在使用迭代器的时候，也会产生相同的弱一致性问题。
- 创建副本的操作会消耗内存，如果原数组较大，那么就会消耗很多内存，可能出现ygc和fgc。

