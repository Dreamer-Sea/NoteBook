# Java多线程 2
[toc]

## 并行与并发
- 并行：同一时间点有多个线程在同时运行。
- 并发：同一时间段有多个线程在运行。

## 共享资源
能被多个线程持有或访问的资源被称为共享资源。

## 内存模型
在早先的Java内存模型(JMM)中，线程都能直接访问主内存，所以不存在内存可见性的问题。但是线程的速度和内存的速度有着明显的差距。在任务简单的时候，这个速度差不会显著的影响任务的执行速度，但是任务繁重的时候，这个速度差就有很大的影响了。所以在这个背景下，新的JMM在线程和主内存中加入了本地内存(例如寄存器)，使得每个线程都有自己独占的本地内存，并且线程A不能访问线程B的本地内存。但是这就产生了一个问题，线程更新了本地内存中的变量后，可能不会立马将变量写回主内存中，所以i其它线程的本地内存中的变量还是旧值，进而产生线程不安全的问题。
使用Java中的volatile关键字能够解决这个问题。

## synchronized关键字
### 简介
Java中内置的，使用者看不到的锁被称为内部锁，也成为监视器锁。内置锁都是排他锁。
Java中的线程是与操作系统的原生线程一一对应的，所以当一个线程被阻塞时，就需要从用户态切换到内核态执行阻塞操作，耗费时间和资源。
### 内存语义
进入synchronized代码块的语义：把在synchronized块内使用到的变量从线程的工作内存中清除，这样在synchronized块内使用到该变量时就不会从线程的工作内存中获取，而是直接从主内存中获取。
退出synchronized块的语义：是把在synchronized块内对共享变量的修改刷新到主内存。

## volatile关键字
### 简介
一个弱形式的同步，能够确保对一个变量的更新立马被其它线程马上可见。
### 使用场景
- 写入变量值不依赖变量的当前值时；
- 读写变量值时没有加锁。

## synchronized关键字和volatile关键字的对比
- 两者都解决了可见性的问题；
- 后者不保证操作的原子性。

## 原子性操作
### 定义
指执行一系列操作时，这些操作要么全部执行，要么全部不执行。

## CAS操作
### 简介
CAS(Compare and Swap)，由JDK提供的非阻塞原子性操作，它通过硬件保证了比较-更新操作的原子性。
### ABA问题
变量X的值为A，经过CAS操作，变为B，再经过CAS操作，变为A。虽然初始值和最终值都为A，但是他们是不同的(同一个对象/内存地址，不同的内容)。
JDK中提供了AtomicStampedReference类来给每个变量的状态值都配备了一个时间戳，从而避免了ABA问题的产生。

## Unsafe类
### 简介
该类在rt.jar包下，提供了硬件级别的原子性操作，其中的方法都是native方法。

## 指令重排
### 定义
JMM允许编译器和处理器对指令进行重排序从而提高运行性能，并且只会对不存在数据依赖性的指令重排序。
在多线程的情况下，重排序会导致非预期结果的出现。
### 解决方法
用volatile关键字修饰变量，就能够解决指令重排和内存可见性的问题。

## 伪共享
### 定义
为了解决CPU和主内存之间速度差的问题，会在两者中间加入一级或多级高速缓存存储器(Cache)。Cache的内部是按行存储的，Cache行的大小一般为2的幂次数节。
当CPU访问某个变量的时候，会先从Cache中查找，如果有则直接获取，如果没有则从主内存中获取。由于在Cache行中存储的是内存块，所以一个Cache行可能会有多个变量。而每次更新Cache行都会整个更新，所以更新一个变量可能导致同一个Cache行中的所有变量都被更新。使得当前的缓存失效，从而必须去更低级的缓存中获取值。
### 解决方案
JDK 1.8之前：
使用字节填充的方式。一个类对象的字节码的对象头占8字节。
JDK 1.8之后：
使用@sum.misc.Contended注解。需要添加JVM参数：-XX:RestrictContended，默认宽度128。自定义宽度则可以设置-XX:ContendedPaddingWidth参数。

## 乐观锁 & 悲观锁
- 悲观锁：悲观锁认为数据的每一次操作都需要加锁。
- 乐观锁：乐观锁认为数据的每次操作都不会造成冲突，所以不会加锁。

## 公平锁 & 非公平锁
- 公平锁：根据线程请求锁的时间的早晚来决定的。
- 非公平锁：线程通过竞争来获得锁。

## 独占锁 & 共享锁
- 独占锁：只能被单个线程持有，例如，ReentrantLock。
- 共享锁：能被多个线程持有，例如，ReadWriteLock。

## 可重入锁
持有锁的线程能够重复获得锁，加锁多少次就要解锁多少次。

## 自旋锁
如果线程获取锁失败，不会被阻塞挂起，而是多次尝试获得锁(默认10次，可以使用-XX:PreBlockSpinsh参数来设置该值)。
改进版本：自适应自旋锁，能够根据情况改变尝试次数。
**问题：**自适应自旋锁根据什么来改动尝试次数？

