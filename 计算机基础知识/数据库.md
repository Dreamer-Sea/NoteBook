# 数据库
[toc]
# 存储引擎
## MyISAM
老版本的MYSQL的默认存储引擎。不支持数据库事务，行级锁和外键，因此在插入(INSERT)或更新(UPDATE)数据时需要锁定整个表，效率低。
该引擎读取操作块，且占用内存和存储资源较少。

## InnoDB
该引擎为MySQL提供了事务支持，回滚，崩溃修复能力，多版本并发控制和事务安全的操作。底层的数据结构时B+树。
B+树的每个节点都对应InnnoDB的一个Page，Page的大小是固定的，一般被设为16KB。其中，非叶子节点只有键值，叶子节点包含完整的数据。

### 为什么InnoDB的底层数据结构是B+树，而不是B树
- 区别：
	1. B+树的非叶子节点不存放数据，B树的非叶子节点存放数据。
	2. 在B+树，A节点的最后一个子节点会存放指向A节点兄弟节点的第一个子节点的指针。
- B+树这种将数据都存放在叶子节点，而非叶子节点不存放数据的存储方式，能够提高数据库查询的稳定性。
- B+树的每一节点存储的元素更多，使得查询的IO次数更少。
- 所有叶子节点形成了一个有序的链表，更加便于查找(**模糊搜索**，**范围查询**)。

适用的场景：
- 经常有数据更新的表，适合处理多重并发更新请求。
- 支持事务。
- 支持灾难恢复。
- 支持外键约束。
- 支持自动增长列属性。

## TokuDB
底层数据结构时Fractal Tree，该数据结构与B+树有些类似，只是在Fractal Tree中除了每一个指针，都需要指向一个孩子节点，孩子节点带一个Message Buffer，这个Message Buffer是一个先进先出队列，用来缓存更新操作。这样，每一次插入操作都只需落在某节点的Message Buffer上，就可以马上返回，并不需要搜索到叶子节点。这些缓存的更新操作会在后台异步合并并更新到对应的节点上。
TokuDB在线添加索引，不影响读写操作，有非常高的写如性能，主要适用于要求写入速度块，访问频率不高的数据或历史数据归档。

## Memory
Memory表使用内存空间创建。每个Memory表实际上都对应一个磁盘文件用于持久化。因为表中的数据是存放在内存中的，因此访问速度非常快，通常使用Hash来实现数据索引。Memory表的缺点是一旦服务关闭，，表中数据就会丢失。

# 索引
## 聚簇索引 & 非聚簇索引
- 聚簇索引(主键索引)：叶子节点存储有**整行数据**的索引。
- 非聚簇索引(普通索引)：叶子节点存储有**主键值**的索引。

## 覆盖索引 

# 回表
在使用SQL语句进行查询的时候，需要先从普通索引中找到该普通索引，然后才能得到该普通索引的主键索引的过程。
```sql
1. select * from User where id = 3
2. select * from User where uid = 23
```
第二条SQL语句触发了回表操作，因为根据uid字段只能找到值为23的普通索引，而不能得到其它字段的值，所以找到uid=23这个索引后，需要取出其中存储的主键值，然后得到整行数据。

# 索引的最左前缀原则：
在联合索引的情况下，不需要索引的全部定义，只要满足最左前缀，就可以利用索引来加快查询速度。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符

# 索引下退
MySQL 5.6及之后能够在使用联合索引的前提下，在使用索引遍历的过程中，对索引中包含的其余字段先做判断，直接过滤掉不满足条件的记录，减少回表次数，提升查询效率。

# where，group by和having
- 三者的用途
	- where：用来筛选from子句中指定的操作所产生的行。
	- group by：用来分组where子句的输出。
	- having：用来从分组的结果中筛选行。


# 数据库三范式
## 第一范式
字段必须是不可再分的最小数据单元。
## 第二范式
在第一范式的基础上，表中的非主键列不存在对主键的部分依赖。
## 第三范式
在第二范式的基础上，表中的列不存在对非主键列的传递依赖。